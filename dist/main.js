/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/tone/Tone/core/Tone.js":
/*!*********************************************!*\
  !*** ./node_modules/tone/Tone/core/Tone.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version */ \"./node_modules/tone/Tone/version.js\");\n/**\n *  Tone.js\n *  @author Yotam Mann\n *  @license http://opensource.org/licenses/MIT MIT License\n *  @copyright 2014-2019 Yotam Mann\n */\n\n\n///////////////////////////////////////////////////////////////////////////\n//\tTONE\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  @class  Tone is the base class of all other classes.\n *  @constructor\n */\nvar Tone = function(){\n\tif (!(this instanceof Tone)){\n\t\tthrow new Error(\"constructor needs to be called with the 'new' keyword\");\n\t}\n};\n\n/**\n *  @memberOf Tone#\n *  @returns {String} returns the name of the class as a string\n */\nTone.prototype.toString = function(){\n\tfor (var className in Tone){\n\t\tvar isLetter = className[0].match(/^[A-Z]$/);\n\t\tvar sameConstructor = Tone[className] === this.constructor;\n\t\tif (Tone.isFunction(Tone[className]) && isLetter && sameConstructor){\n\t\t\treturn className;\n\t\t}\n\t}\n\treturn \"Tone\";\n};\n\n/**\n *  @memberOf Tone#\n *  disconnect and dispose\n *  @returns {Tone} this\n */\nTone.prototype.dispose = function(){\n\treturn this;\n};\n\n///////////////////////////////////////////////////////////////////////////\n//\tGET/SET\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Set the parameters at once. Either pass in an\n *  object mapping parameters to values, or to set a\n *  single parameter, by passing in a string and value.\n *  The last argument is an optional ramp time which\n *  will ramp any signal values to their destination value\n *  over the duration of the rampTime.\n *  @param {Object|String} params\n *  @param {Number=} value\n *  @returns {Tone} this\n *  @memberOf Tone#\n *  @example\n * //set values using an object\n * filter.set({\n * \t\"frequency\" : 300,\n * \t\"type\" : highpass\n * });\n *  @example\n * filter.set(\"type\", \"highpass\");\n *  @example\n * //ramp to the value 220 over 3 seconds.\n * oscillator.set({\n * \t\"frequency\" : 220\n * }, 3);\n */\nTone.prototype.set = function(params, value){\n\tif (Tone.isString(params)){\n\t\tvar tmpObj = {};\n\t\ttmpObj[params] = value;\n\t\tparams = tmpObj;\n\t}\n\n\tparamLoop:\n\tfor (var attr in params){\n\t\tvalue = params[attr];\n\t\tvar parent = this;\n\t\tif (attr.indexOf(\".\") !== -1){\n\t\t\tvar attrSplit = attr.split(\".\");\n\t\t\tfor (var i = 0; i < attrSplit.length - 1; i++){\n\t\t\t\tparent = parent[attrSplit[i]];\n\t\t\t\tif (parent instanceof Tone){\n\t\t\t\t\tattrSplit.splice(0, i+1);\n\t\t\t\t\tvar innerParam = attrSplit.join(\".\");\n\t\t\t\t\tparent.set(innerParam, value);\n\t\t\t\t\tcontinue paramLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t\tattr = attrSplit[attrSplit.length - 1];\n\t\t}\n\t\tvar param = parent[attr];\n\t\tif (Tone.isUndef(param)){\n\t\t\tcontinue;\n\t\t}\n\t\tif ((Tone.Signal && param instanceof Tone.Signal) ||\n\t\t\t(Tone.Param && param instanceof Tone.Param)){\n\t\t\tif (param.value !== value){\n\t\t\t\tparam.value = value;\n\t\t\t}\n\t\t} else if (param instanceof AudioParam){\n\t\t\tif (param.value !== value){\n\t\t\t\tparam.value = value;\n\t\t\t}\n\t\t} else if (Tone.TimeBase && param instanceof Tone.TimeBase){\n\t\t\tparent[attr] = value;\n\t\t} else if (param instanceof Tone){\n\t\t\tparam.set(value);\n\t\t} else if (param !== value){\n\t\t\tparent[attr] = value;\n\t\t}\n\t}\n\treturn this;\n};\n\n/**\n *  Get the object's attributes. Given no arguments get\n *  will return all available object properties and their corresponding\n *  values. Pass in a single attribute to retrieve or an array\n *  of attributes. The attribute strings can also include a \".\"\n *  to access deeper properties.\n *  @memberOf Tone#\n *  @example\n * osc.get();\n * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n *  @example\n * osc.get(\"type\");\n * //returns { \"type\" : \"sine\"}\n * @example\n * //use dot notation to access deep properties\n * synth.get([\"envelope.attack\", \"envelope.release\"]);\n * //returns {\"envelope\" : {\"attack\" : 0.2, \"release\" : 0.4}}\n *  @param {Array=|string|undefined} params the parameters to get, otherwise will return\n *  \t\t\t\t\t                  all available.\n *  @returns {Object}\n */\nTone.prototype.get = function(params){\n\tif (Tone.isUndef(params)){\n\t\tparams = this._collectDefaults(this.constructor);\n\t} else if (Tone.isString(params)){\n\t\tparams = [params];\n\t}\n\tvar ret = {};\n\tfor (var i = 0; i < params.length; i++){\n\t\tvar attr = params[i];\n\t\tvar parent = this;\n\t\tvar subRet = ret;\n\t\tif (attr.indexOf(\".\") !== -1){\n\t\t\tvar attrSplit = attr.split(\".\");\n\t\t\tfor (var j = 0; j < attrSplit.length - 1; j++){\n\t\t\t\tvar subAttr = attrSplit[j];\n\t\t\t\tsubRet[subAttr] = subRet[subAttr] || {};\n\t\t\t\tsubRet = subRet[subAttr];\n\t\t\t\tparent = parent[subAttr];\n\t\t\t}\n\t\t\tattr = attrSplit[attrSplit.length - 1];\n\t\t}\n\t\tvar param = parent[attr];\n\t\tif (Tone.isObject(params[attr])){\n\t\t\tsubRet[attr] = param.get();\n\t\t} else if (Tone.Signal && param instanceof Tone.Signal){\n\t\t\tsubRet[attr] = param.value;\n\t\t} else if (Tone.Param && param instanceof Tone.Param){\n\t\t\tsubRet[attr] = param.value;\n\t\t} else if (param instanceof AudioParam){\n\t\t\tsubRet[attr] = param.value;\n\t\t} else if (param instanceof Tone){\n\t\t\tsubRet[attr] = param.get();\n\t\t} else if (!Tone.isFunction(param) && Tone.isDefined(param)){\n\t\t\tsubRet[attr] = param;\n\t\t}\n\t}\n\treturn ret;\n};\n\n/**\n *  collect all of the default attributes in one\n *  @private\n *  @param {Function} constr the constructor to find the defaults from\n *  @return {Array} all of the attributes which belong to the class\n */\nTone.prototype._collectDefaults = function(constr){\n\tvar ret = [];\n\tif (Tone.isDefined(constr.defaults)){\n\t\tret = Object.keys(constr.defaults);\n\t}\n\tif (Tone.isDefined(constr._super)){\n\t\tvar superDefs = this._collectDefaults(constr._super);\n\t\t//filter out repeats\n\t\tfor (var i = 0; i < superDefs.length; i++){\n\t\t\tif (ret.indexOf(superDefs[i]) === -1){\n\t\t\t\tret.push(superDefs[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n};\n\n///////////////////////////////////////////////////////////////////////////\n//\tDEFAULTS\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  @memberOf Tone\n *  @param  {Array}  values  The arguments array\n *  @param  {Array}  keys    The names of the arguments\n *  @param {Function|Object} constr The class constructor\n *  @return  {Object}  An object composed of the  defaults between the class' defaults\n *                        and the passed in arguments.\n */\nTone.defaults = function(values, keys, constr){\n\tvar options = {};\n\tif (values.length === 1 && Tone.isObject(values[0])){\n\t\toptions = values[0];\n\t} else {\n\t\tfor (var i = 0; i < keys.length; i++){\n\t\t\toptions[keys[i]] = values[i];\n\t\t}\n\t}\n\tif (Tone.isDefined(constr.defaults)){\n\t\treturn Tone.defaultArg(options, constr.defaults);\n\t} else if (Tone.isObject(constr)){\n\t\treturn Tone.defaultArg(options, constr);\n\t} else {\n\t\treturn options;\n\t}\n};\n\n/**\n *  If the `given` parameter is undefined, use the `fallback`.\n *  If both `given` and `fallback` are object literals, it will\n *  return a deep copy which includes all of the parameters from both\n *  objects. If a parameter is undefined in given, it will return\n *  the fallback property.\n *  <br><br>\n *  WARNING: if object is self referential, it will go into an an\n *  infinite recursive loop.\n *  @memberOf Tone\n *  @param  {*} given\n *  @param  {*} fallback\n *  @return {*}\n */\nTone.defaultArg = function(given, fallback){\n\tif (Tone.isObject(given) && Tone.isObject(fallback)){\n\t\tvar ret = {};\n\t\t//make a deep copy of the given object\n\t\tfor (var givenProp in given){\n\t\t\tret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);\n\t\t}\n\t\tfor (var fallbackProp in fallback){\n\t\t\tret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n\t\t}\n\t\treturn ret;\n\t} else {\n\t\treturn Tone.isUndef(given) ? fallback : given;\n\t}\n};\n\n///////////////////////////////////////////////////////////////////////////\n//\tDEBUGGING\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Print the outputs to the console log for debugging purposes. \n *  Prints the contents only if either the object has a property\n *  called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n *  is set to the name of the class. \n *  @example\n * //prints all logs originating from Tone.OscillatorNode\n * Tone.global.TONE_DEBUG_CLASS = \"OscillatorNode\"\n *  @param {*} args Any arguments to print to the console.\n *  @private\n */\nTone.prototype.log = function(){\n\t//if the object is either set to debug = true\n\t//or if there is a string on the Tone.global.with the class name\n\tif (this.debug || this.toString() === Tone.global.TONE_DEBUG_CLASS){\n\t\tvar args = Array.from(arguments);\n\t\targs.unshift(this.toString()+\":\");\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log.apply(undefined, args);\n\t}\n};\n\n/**\n *  Assert that the statement is true, otherwise invoke the error. \n *  @param {Boolean} statement\n *  @param {String} error The message which is passed into an Error\n *  @private\n */\nTone.prototype.assert = function(statement, error){\n\tif (!statement){\n\t\tthrow new Error(error);\n\t}\n};\n\n///////////////////////////////////////////////////////////////////////////\n//\tCONNECTIONS\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  connect together all of the arguments in series\n *  @param {...(AudioParam|Tone|AudioNode)} nodes\n *  @returns {Tone}\n *  @memberOf Tone\n *  @static\n */\nTone.connectSeries = function(){\n\tvar currentUnit = arguments[0];\n\tfor (var i = 1; i < arguments.length; i++){\n\t\tvar toUnit = arguments[i];\n\t\tTone.connect(currentUnit, toUnit);\n\t\tcurrentUnit = toUnit;\n\t}\n\treturn Tone;\n};\n\n/**\n * Connect two nodes together so that signal flows from the \n * first node to the second. The second node can be an AudioParam. \n * Optionally specific the input and output channels. \n * @param {(AudioNode|Tone.AudioNode)} srcNode The source node\n * @param {(AudioNode|Tone.AudioNode|AudioParam|Tone.AudioParam)} dstNode The destination node\n * @param {number} [outputNumber=0] The output channel of the srcNode\n * @param {number} [inputNumber=0] The input channel of the dstNode\n */\nTone.connect = function(srcNode, dstNode, outputNumber, inputNumber){\n\t\n\t//resolve the input of the dstNode\n\twhile (Tone.isDefined(dstNode.input)){\n\t\tif (Tone.isArray(dstNode.input)){\n\t\t\tinputNumber = Tone.defaultArg(inputNumber, 0);\n\t\t\tdstNode = dstNode.input[inputNumber];\n\t\t\tinputNumber = 0;\n\t\t} else if (dstNode.input){\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\t//make the connection\n\tif (dstNode instanceof AudioParam){\n\t\tsrcNode.connect(dstNode, outputNumber);\n\t} else if (dstNode instanceof AudioNode){\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n\n\treturn Tone;\n};\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param {(AudioNode|Tone.AudioNode)} srcNode The source node\n * @param {?(AudioNode|Tone.AudioNode|AudioParam|Tone.AudioParam)} dstNode The destination node\n * @param {?number} [outputNumber=0] The output channel of the srcNode\n * @param {?number} [inputNumber=0] The input channel of the dstNode\n */\nTone.disconnect = function(srcNode, dstNode, outputNumber, inputNumber){\n\tif (dstNode){\n\t\t//resolve the input of the dstNode\n\t\tvar bDone = false;\n\t\twhile (!bDone){\n\t\t\tif (Tone.isArray(dstNode.input)){\n\t\t\t\tif (Tone.isDefined(inputNumber)){\n\t\t\t\t\tTone.disconnect(srcNode, dstNode.input[inputNumber], outputNumber);\n\t\t\t\t} else {\n\t\t\t\t\tdstNode.input.forEach(function(dstNode){\n\t\t\t\t\t\t//ignore errors from connections that aren't there\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tTone.disconnect(srcNode, dstNode, outputNumber);\n\t\t\t\t\t\t// eslint-disable-next-line\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbDone = true;\n\t\t\t} else if (dstNode.input){\n\t\t\t\tdstNode = dstNode.input;\n\t\t\t} else {\n\t\t\t\tbDone = true;\n\t\t\t}\n\t\t}\n\t\n\t\t//make the connection\n\t\tif (dstNode instanceof AudioParam){\n\t\t\tsrcNode.disconnect(dstNode, outputNumber);\n\t\t} else if (dstNode instanceof AudioNode){\n\t\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t\t}\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n\n\treturn Tone;\n};\n\n///////////////////////////////////////////////////////////////////////////\n// TYPE CHECKING\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Test if the arg is undefined\n *  @param {*} arg the argument to test\n *  @returns {Boolean} true if the arg is undefined\n *  @static\n *  @memberOf Tone\n */\nTone.isUndef = function(val){\n\treturn typeof val === \"undefined\";\n};\n\n/**\n *  Test if the arg is not undefined\n *  @param {*} arg the argument to test\n *  @returns {Boolean} true if the arg is undefined\n *  @static\n *  @memberOf Tone\n */\nTone.isDefined = function(val){\n\treturn !Tone.isUndef(val);\n};\n\n/**\n *  Test if the arg is a function\n *  @param {*} arg the argument to test\n *  @returns {Boolean} true if the arg is a function\n *  @static\n *  @memberOf Tone\n */\nTone.isFunction = function(val){\n\treturn typeof val === \"function\";\n};\n\n/**\n *  Test if the argument is a number.\n *  @param {*} arg the argument to test\n *  @returns {Boolean} true if the arg is a number\n *  @static\n *  @memberOf Tone\n */\nTone.isNumber = function(arg){\n\treturn (typeof arg === \"number\");\n};\n\n/**\n *  Test if the given argument is an object literal (i.e. `{}`);\n *  @param {*} arg the argument to test\n *  @returns {Boolean} true if the arg is an object literal.\n *  @static\n *  @memberOf Tone\n */\nTone.isObject = function(arg){\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n};\n\n/**\n *  Test if the argument is a boolean.\n *  @param {*} arg the argument to test\n *  @returns {Boolean} true if the arg is a boolean\n *  @static\n *  @memberOf Tone\n */\nTone.isBoolean = function(arg){\n\treturn (typeof arg === \"boolean\");\n};\n\n/**\n *  Test if the argument is an Array\n *  @param {*} arg the argument to test\n *  @returns {Boolean} true if the arg is an array\n *  @static\n *  @memberOf Tone\n */\nTone.isArray = function(arg){\n\treturn (Array.isArray(arg));\n};\n\n/**\n *  Test if the argument is a string.\n *  @param {*} arg the argument to test\n *  @returns {Boolean} true if the arg is a string\n *  @static\n *  @memberOf Tone\n */\nTone.isString = function(arg){\n\treturn (typeof arg === \"string\");\n};\n\n/**\n *  Test if the argument is in the form of a note in scientific pitch notation.\n *  e.g. \"C4\"\n *  @param {*} arg the argument to test\n *  @returns {Boolean} true if the arg is a string\n *  @static\n *  @memberOf Tone\n */\nTone.isNote = function(arg){\n\treturn Tone.isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n};\n\n/**\n *  An empty function.\n *  @static\n */\nTone.noOp = function(){};\n\n/**\n *  Make the property not writable. Internal use only.\n *  @private\n *  @param  {String}  property  the property to make not writable\n */\nTone.prototype._readOnly = function(property){\n\tif (Array.isArray(property)){\n\t\tfor (var i = 0; i < property.length; i++){\n\t\t\tthis._readOnly(property[i]);\n\t\t}\n\t} else {\n\t\tObject.defineProperty(this, property, {\n\t\t\t\"writable\" : false,\n\t\t\t\"enumerable\" : true,\n\t\t});\n\t}\n};\n\n/**\n *  Make an attribute writeable. Interal use only.\n *  @private\n *  @param  {String}  property  the property to make writable\n */\nTone.prototype._writable = function(property){\n\tif (Array.isArray(property)){\n\t\tfor (var i = 0; i < property.length; i++){\n\t\t\tthis._writable(property[i]);\n\t\t}\n\t} else {\n\t\tObject.defineProperty(this, property, {\n\t\t\t\"writable\" : true,\n\t\t});\n\t}\n};\n\n/**\n * Possible play states.\n * @enum {String}\n */\nTone.State = {\n\t\"Started\" : \"started\",\n\t\"Stopped\" : \"stopped\",\n\t\"Paused\" : \"paused\",\n};\n\n/**\n * A reference to the global context, `global` or `Tone.global.\n */\nTone.global = Tone.isUndef(global) ? window : global;\n\n///////////////////////////////////////////////////////////////////////////\n// CONVERSIONS\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Equal power gain scale. Good for cross-fading.\n *  @param  {NormalRange} percent (0-1)\n *  @return {Number}         output gain (0-1)\n *  @static\n *  @memberOf Tone\n */\nTone.equalPowerScale = function(percent){\n\tvar piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n};\n\n/**\n *  Convert decibels into gain.\n *  @param  {Decibels} db\n *  @return {Number}\n *  @static\n *  @memberOf Tone\n */\nTone.dbToGain = function(db){\n\treturn Math.pow(10, db / 20);\n};\n\n/**\n *  Convert gain to decibels.\n *  @param  {Number} gain (0-1)\n *  @return {Decibels}\n *  @static\n *  @memberOf Tone\n */\nTone.gainToDb = function(gain){\n\treturn 20 * (Math.log(gain) / Math.LN10);\n};\n\n/**\n *  Convert an interval (in semitones) to a frequency ratio.\n *  @param  {Interval} interval the number of semitones above the base note\n *  @return {Number}          the frequency ratio\n *  @static\n *  @memberOf Tone\n *  @example\n * tone.intervalToFrequencyRatio(0); // 1\n * tone.intervalToFrequencyRatio(12); // 2\n * tone.intervalToFrequencyRatio(-12); // 0.5\n */\nTone.intervalToFrequencyRatio = function(interval){\n\treturn Math.pow(2, (interval/12));\n};\n\n///////////////////////////////////////////////////////////////////////////\n//\tTIMING\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Return the current time of the AudioContext clock plus\n *  the lookAhead.\n *  @return {Number} the currentTime from the AudioContext\n *  @memberOf Tone#\n */\nTone.prototype.now = function(){\n\treturn Tone.context.now();\n};\n\n/**\n *  Return the current time of the AudioContext clock plus\n *  the lookAhead.\n *  @return {Number} the currentTime from the AudioContext\n *  @static\n *  @memberOf Tone\n */\nTone.now = function(){\n\treturn Tone.context.now();\n};\n\n/**\n *  Return the current time of the AudioContext clock without\n *  any lookAhead.\n *  @return {Number} the currentTime from the AudioContext\n *  @memberOf Tone#\n */\nTone.prototype.immediate = function(){\n\treturn Tone.context.currentTime;\n};\n\n/**\n *  Return the current time of the AudioContext clock without\n *  any lookAhead.\n *  @return {Number} the currentTime from the AudioContext\n *  @memberOf Tone\n */\nTone.immediate = function(){\n\treturn Tone.context.currentTime;\n};\n\n///////////////////////////////////////////////////////////////////////////\n//\tINHERITANCE\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  have a child inherit all of Tone's (or a parent's) prototype\n *  to inherit the parent's properties, make sure to call\n *  Parent.call(this) in the child's constructor\n *\n *  based on closure library's inherit function\n *\n *  @memberOf Tone\n *  @static\n *  @param  {Function} \tchild\n *  @param  {Function=} parent (optional) parent to inherit from\n *                             if no parent is supplied, the child\n *                             will inherit from Tone\n */\nTone.extend = function(child, parent){\n\tif (Tone.isUndef(parent)){\n\t\tparent = Tone;\n\t}\n\tfunction TempConstructor(){}\n\tTempConstructor.prototype = parent.prototype;\n\tchild.prototype = new TempConstructor();\n\t/** @override */\n\tchild.prototype.constructor = child;\n\tchild._super = parent;\n};\n\n///////////////////////////////////////////////////////////////////////////\n//\tCONTEXT\n///////////////////////////////////////////////////////////////////////////\n\n/**\n * The shared AudioContext\n * @type {Tone.Context}\n * @private\n */\nTone._audioContext = null;\n\n/**\n * \tMost browsers will not play _any_ audio until a user \n * \tclicks something (like a play button). Invoke this method\n * \ton a click or keypress event handler to start the audio context. \n * \tMore about the Autoplay policy [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n *  @memberOf Tone\n *  @static\n *  @return {Promise} This promise is resolved when the audio context is started. \n *  @example\n * document.querySelector('#playbutton').addEventListener('click', () => Tone.start())\n */\nTone.start = function(){\n\treturn Tone.context.resume();\n};\n\n/**\n *  A static pointer to the audio context accessible as Tone.context.\n *  @type {Tone.Context}\n *  @name context\n *  @memberOf Tone\n */\nObject.defineProperty(Tone, \"context\", {\n\t\"get\" : function(){\n\t\treturn Tone._audioContext;\n\t},\n\t\"set\" : function(context){\n\t\tif (context.isContext){\n\t\t\tTone._audioContext = context;\n\t\t} else {\n\t\t\tTone._audioContext = new Tone.Context(context);\n\t\t}\n\t\t//initialize the new audio context\n\t\tTone.Context.emit(\"init\", Tone._audioContext);\n\t}\n});\n\n/**\n *  The AudioContext\n *  @type {Tone.Context}\n *  @name context\n *  @memberOf Tone#\n *  @readOnly\n */\nObject.defineProperty(Tone.prototype, \"context\", {\n\t\"get\" : function(){\n\t\treturn Tone.context;\n\t}\n});\n\n/**\n *  Tone automatically creates a context on init, but if you are working\n *  with other libraries which also create an AudioContext, it can be\n *  useful to set your own. If you are going to set your own context,\n *  be sure to do it at the start of your code, before creating any objects.\n *  @static\n *  @param {AudioContext} ctx The new audio context to set\n */\nTone.setContext = function(ctx){\n\tTone.context = ctx;\n};\n\n///////////////////////////////////////////////////////////////////////////\n//\tATTRIBUTES\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  The number of seconds of 1 processing block (128 samples)\n *  @type {Number}\n *  @name blockTime\n *  @memberOf Tone\n *  @static\n *  @readOnly\n */\nObject.defineProperty(Tone.prototype, \"blockTime\", {\n\t\"get\" : function(){\n\t\treturn 128 / this.context.sampleRate;\n\t}\n});\n\n/**\n *  The duration in seconds of one sample.\n *  @type {Number}\n *  @name sampleTime\n *  @memberOf Tone\n *  @static\n *  @readOnly\n */\nObject.defineProperty(Tone.prototype, \"sampleTime\", {\n\t\"get\" : function(){\n\t\treturn 1 / this.context.sampleRate;\n\t}\n});\n\n/**\n *  Whether or not all the technologies that Tone.js relies on are supported by the current browser.\n *  @type {Boolean}\n *  @name supported\n *  @memberOf Tone\n *  @readOnly\n *  @static\n */\nObject.defineProperty(Tone, \"supported\", {\n\t\"get\" : function(){\n\t\tvar hasAudioContext = Tone.global.hasOwnProperty(\"AudioContext\") || Tone.global.hasOwnProperty(\"webkitAudioContext\");\n\t\tvar hasPromises = Tone.global.hasOwnProperty(\"Promise\");\n\t\treturn hasAudioContext && hasPromises;\n\t}\n});\n\n/**\n *  Boolean value if the audio context has been initialized.\n *  @type {Boolean}\n *  @memberOf Tone\n *  @static\n *  @name initialized\n *  @readOnly\n */\nObject.defineProperty(Tone, \"initialized\", {\n\t\"get\" : function(){\n\t\treturn Boolean(Tone.context);\n\t}\n});\n\n/**\n *  Get the context when it becomes available\n *  @param  {Function}  resolve  Callback when the context is initialized\n *  @return  {Tone}\n */\nTone.getContext = function(resolve){\n\tif (Tone.initialized){\n\t\tresolve(Tone.context);\n\t} else {\n\t\tvar resCallback = function(){\n\t\t\tresolve(Tone.context);\n\t\t\tTone.Context.off(\"init\", resCallback);\n\t\t};\n\t\tTone.Context.on(\"init\", resCallback);\n\t}\n\treturn Tone;\n};\n\n/**\n * The version number\n * @type {String}\n * @static\n */\nTone.version = _version__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Tone);\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/tone/Tone/core/Tone.js?");

/***/ }),

/***/ "./node_modules/tone/Tone/version.js":
/*!*******************************************!*\
  !*** ./node_modules/tone/Tone/version.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"13.8.25\");\n\n\n//# sourceURL=webpack:///./node_modules/tone/Tone/version.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_tone_Tone_core_Tone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/tone/Tone/core/Tone */ \"./node_modules/tone/Tone/core/Tone.js\");\n\n\nconst ac = new window.AudioContext()\n\n_node_modules_tone_Tone_core_Tone__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setContext(ac)\n\n\nwindow.ToneCopy = function(){\n    this.tone = _node_modules_tone_Tone_core_Tone__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n\n}\n\n\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });